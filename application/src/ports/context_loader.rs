//! Context loader port
//!
//! This module defines the [`ContextLoaderPort`] trait, which abstracts
//! file system operations for loading project context files.
//!
//! # Overview
//!
//! The context loader is responsible for:
//!
//! - Loading known context files (CLAUDE.md, README.md, etc.)
//! - Checking for the existence of the quorum context file
//! - Writing generated context files
//! - Building `ProjectContext` from loaded files
//!
//! # Port Pattern
//!
//! This trait follows the ports and adapters (hexagonal) architecture pattern.
//! The application layer defines the interface, and the infrastructure layer
//! provides concrete implementations (e.g., `LocalContextLoader`).
//!
//! # Example
//!
//! ```ignore
//! use quorum_application::ContextLoaderPort;
//! use std::path::Path;
//!
//! fn gather_context<C: ContextLoaderPort>(loader: &C, project_root: &Path) {
//!     // Check if context already exists
//!     if loader.context_file_exists(project_root) {
//!         println!("Context file found!");
//!     }
//!
//!     // Load all known files
//!     let files = loader.load_known_files(project_root);
//!     let context = loader.build_project_context(files);
//!
//!     if context.has_sufficient_context() {
//!         println!("Sufficient context available");
//!     }
//! }
//! ```

use quorum_domain::{LoadedContextFile, ProjectContext};
use std::path::Path;

/// Port for loading project context from the file system.
///
/// This trait abstracts the file system operations needed to load
/// known context files (CLAUDE.md, README.md, etc.) from a project.
/// It enables the application layer to remain independent of the
/// specific file system implementation.
///
/// # Implementors
///
/// - `LocalContextLoader` - Reads from the local file system
///
/// # Thread Safety
///
/// Implementations must be `Send + Sync` to allow use in async contexts
/// and across thread boundaries.
pub trait ContextLoaderPort: Send + Sync {
    /// Loads all known context files from the project root.
    ///
    /// This method scans the project directory for known context files
    /// (CLAUDE.md, README.md, Cargo.toml, etc.) and loads their contents.
    ///
    /// # Arguments
    ///
    /// * `project_root` - The root directory of the project
    ///
    /// # Returns
    ///
    /// A list of successfully loaded files, sorted by priority.
    /// Files that don't exist or can't be read are silently skipped.
    ///
    /// # Known File Types
    ///
    /// The loader checks for these files in priority order:
    ///
    /// 1. `.quorum/context.md` - Generated context
    /// 2. `CLAUDE.md` - Local project instructions
    /// 3. `~/.claude/CLAUDE.md` - Global Claude config
    /// 4. `README.md` - Project readme
    /// 5. `docs/**/*.md` - Documentation files
    /// 6. `Cargo.toml`, `package.json`, `pyproject.toml` - Build configs
    fn load_known_files(&self, project_root: &Path) -> Vec<LoadedContextFile>;

    /// Checks if the quorum context file exists.
    ///
    /// The quorum context file (`.quorum/context.md`) is generated by
    /// the `/init` command and takes highest priority among context sources.
    ///
    /// # Arguments
    ///
    /// * `project_root` - The root directory of the project
    ///
    /// # Returns
    ///
    /// `true` if `.quorum/context.md` exists and is a file.
    fn context_file_exists(&self, project_root: &Path) -> bool;

    /// Builds a `ProjectContext` from loaded files.
    ///
    /// This is a convenience method that delegates to
    /// [`ProjectContext::from_files`]. Implementors can override this
    /// if custom processing is needed.
    ///
    /// # Arguments
    ///
    /// * `files` - List of loaded context files
    ///
    /// # Returns
    ///
    /// A `ProjectContext` containing the aggregated context information.
    fn build_project_context(&self, files: Vec<LoadedContextFile>) -> ProjectContext {
        ProjectContext::from_files(files)
    }

    /// Writes the generated context file.
    ///
    /// This method creates the `.quorum/context.md` file with the
    /// provided content. It should create the parent directory if
    /// it doesn't exist.
    ///
    /// # Arguments
    ///
    /// * `project_root` - The root directory of the project
    /// * `content` - The content to write to the context file
    ///
    /// # Returns
    ///
    /// `Ok(())` on success, or an `std::io::Error` on failure.
    ///
    /// # Errors
    ///
    /// This function will return an error if:
    ///
    /// - The parent directory can't be created
    /// - The file can't be written (permissions, disk full, etc.)
    fn write_context_file(&self, project_root: &Path, content: &str) -> std::io::Result<()>;

    /// Gets the path to the context file.
    ///
    /// Returns the full path where the quorum context file should be
    /// located (`.quorum/context.md` relative to project root).
    ///
    /// # Arguments
    ///
    /// * `project_root` - The root directory of the project
    ///
    /// # Returns
    ///
    /// The full path to the context file.
    fn context_file_path(&self, project_root: &Path) -> std::path::PathBuf {
        project_root.join(".quorum/context.md")
    }
}
